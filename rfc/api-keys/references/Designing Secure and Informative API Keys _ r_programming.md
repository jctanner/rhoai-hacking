# Designing Secure and Informative API Keys _ r_programming

**Source:** `Designing Secure and Informative API Keys _ r_programming.pdf`

---

Designing Secure and Informative API Keys : r/programming

1 of 7

r/programming

https://www.reddit.com/r/programming/comments/1g6qkai/...

Search in r/programming

Create

r/programming • 1y ago
punkpeye

Designing Secure and Informative API Keys

glama.ai

Open

113

36

Share

Join the conversation
Search Comments

Sort by: Best

rehevkor5 • 1y ago

See also https://github.blog/engineering/platform-security/behind-githubs-new-authentication-tokenformats/
16

Reply

MafiaMan456 • 1y ago

API keys are not a modern, secure way of authentication/authorization. They are easily leaked, can be

2/27/26, 1:18 PM

Designing Secure and Informative API Keys : r/programming

2 of 7

https://www.reddit.com/r/programming/comments/1g6qkai/...

API keys are not a modern, secure way of authentication/authorization. They are easily leaked, can be
checked into source
code, lifecycle management is manual and they don’t contain any
extra information
r/programming
Create
about the client or lifecycle like tokens do.
Source: Security champion in a major 1st party service in a major cloud provider. We spent years
deprecating API keys for our own backend auth as well as front end customer facing client auth. Internal
services were banned from using API keys for authentication. Use platform supported identities or a 3rd
party token provider. If you’re building the actual auth platform, use certificate based auth with short-lived
constantly rotating certificates using subject-name-issuer (SNI) auth instead of thumbprint based to
support live rotations.
56

Reply

punkpeye OP • 1y ago

Would love to read more about best practices. Any recommended readings?
34

Reply

amestrianphilosopher • 1y ago

Now tell me, how are you going to authenticate with the 3rd party token provider? A static username
and password
39

Reply

Actual_Ad2119 • 1y ago

The OIDC spec already has that covered - client_secret_jwt. On a token request, a client crafts a
JWT assertion that contains a message authentication code (MAC) in its signature part, and
includes it to the request. Then an authorization server authenticates the client by verifying the
signature and payload of the assertion.
5

Reply

PeksyTiger • 1y ago

And unlike api keys, encryption keys can't be checked into source code or easily leaked /s
21

Reply

amestrianphilosopher • 1y ago

Ok, and for the thing authenticating with your OIDC service, what are they passing in the
Authorization header?

Actual_Ad2119 • 1y ago

The service could just forward the request directly to the OIDC server or, use the exact
same scheme!
client_x_jwt methods allow all kinds of claims (including client id, subject etc) to be
embedded as part of the token itself & Just like client_secret_basic (similar to API keys
that OP is alluding to), client_secret_jwt is also a Client Authentication method used by

2/27/26, 1:18 PM

Designing Secure and Informative API Keys : r/programming

3 of 7

https://www.reddit.com/r/programming/comments/1g6qkai/...

Clients to authenticate to the Authorization Server when using the Token Endpoint.
r/programming
Create
So, if you have a service that relies on the OpenID authorisation server, then it’ll just check
for said claims within the token itself. The authenticity of the token is guaranteed by the
signature and so the actual secrets are never shared by clients while authenticating

amestrianphilosopher • 1y ago

Sure thing, but at the end of the day, I was granted a jwt with access based off of a
static identifier. There’s no problem with API keys as a concept, it’s just that they
should also only be granted tokens with a limited lifespan is my point

Actual_Ad2119 • 1y ago

That’s clearly not what you said in your original comment. So, what is it that you
don’t like? Static credentials to identify clients? Dynamic signatures generated by
static credentials to identify clients? Long lived tokens associated with static
credentials to identify clients?
You either trust a client, or you don’t. If you don’t, then there’s no point in
generating credentials for them and you should expect the token negotiation to be
done through code challenges/verification.
If, however, you do trust the client, then there’s no harm in assigning credentials to
them as long as you have string guards for authentication. The method that I
described, goes a step beyond basic auth and ensures that actual credentials are
never transmitted over the wire. Note that doing code challenges/verification for
trusted clients is also possible - it’s just not what’s actually done in practice
I’m going to ignore the short lived tokens bit since that’s use case dependent There are genuine scenarios where you might need a token to stay alive for a few
months

MafiaMan456 • 1y ago

Auto-rotating, short lived certificates with SNI auth.

amestrianphilosopher • 1y ago

Totally. Now how are you going to gain access to the private key for those auto rotating
certificates? Actually, I’ll add onto that, how are you going to distribute them and assign
identity to each certificate? I assume you’ll need some kind of platform… which your users are
going to need individual access to when they make modifications to their service

MafiaMan456 • 1y ago

2/27/26, 1:18 PM

Designing Secure and Informative API Keys : r/programming

4 of 7

https://www.reddit.com/r/programming/comments/1g6qkai/...

1y ago

You’re
also confusing client/user auth from service auth. Those are totally
r/programming
Createdifferent things
and yes you won’t get away from username password for user auth.

MafiaMan456 • 1y ago

Identity based auth. Have you even worked in security?

amestrianphilosopher • 1y ago

I have actually, and pretty extensively on this exact problem, constantly fighting the
bullshit spewed by people like you :)
Tell me what the actual mechanism is behind this “identity based auth.” How do you
know the person on the other side is who they say they are? Through an Authorization
header perhaps… with some kind of static string that only that person knows?

Luvax • 1y ago

All the people I've met that claim to have solved API Keys are using some form of
bullshit framework or library that just complicates the process by including
additional third parties. Makes sense for other reasons but just because the preshares secret isn't transmitted directly, doesn't make it more secure.
Software security has become a huge market with loads of compliance, fancy
words and vendor locked solutions. All hoping to get some form of government
approval.

MafiaMan456 • 1y ago

… tokens. Christ I’m arguing with an idiot who thinks banks and government
institutions still use API keys

nyctrainsplant • 1y ago

Authentication by definition relies on a shared secret. You can create as many
levels of indirection as you want (to support revocations, transparency, or just
for lock-in to an intentionally convoluted cloud product) but it some point the
buck stops with secrets.
And yes, biometrics are still a secret.

mouse_8b • 1y ago

Plenty of third party providers offer passwordless and MFA these days.

2/27/26, 1:18 PM

Designing Secure and Informative API Keys : r/programming

5 of 7

https://www.reddit.com/r/programming/comments/1g6qkai/...

Plenty of third party providers offer passwordless and MFA these days.
r/programming

Create

Worth_Trust_3825 • 1y ago

preshared secrets, then go from there to generate signed messages

[deleted] • 1y ago

Sometimes you don’t have the time or budget to implement a “proper” solution so using and storing
api keys in something like GitHub actions secrets is the best possible option.

[deleted] • 1y ago

Whatever you'll end up doing is just going to be depending on some sort of "secret sauce" that proves
authenticity; just annoying to work with for everyone involved. Somebody gotta issue those certificates
and they need private key to do so, well outsource this to another service, now you need
authentication for that service as well. And now you can easily expose all the other services depend
on your certificate issuer service for authentication, not just one.
Make them fine grained, you'll get annoyed users just gaining as much permissions as possible and
use them. Security practices usually only focus on technical aspect of the problem usually forgetting
why people "expose" those keys in the first place. By implementing the new technical measures you
overcomplicate it so much that now people have more reasons to just hand off whatever they have to
the other person in order to let them autenticate with the service.
To me I feel like security measures had just become art of blaming someone else. Nobody wants to
take risks and hold responsibility, especially the business unit who are mostly incapable of realizing
that it's impossible to make something absolutely secure. You can just add walls and take measures
to decrease the chance of any security issue happening. But there's always a risk of some exec
putting their password on some website claiming to be an application for the extra bonus program.

braiam • 1y ago

API keys are more about id-ing the product than the end user. It's like NTP servers, where they give
you your own subdomain.

rashnull • 1y ago

Banana factory?

ritaPitaMeterMaid • 1y ago • Edited 1y ago

This is interesting. I'm curious how the author determined that the Sentry API key was Base64URL
encoded, I wouldn't have been able to deduce that just by looking at it.

2/27/26, 1:18 PM

Designing Secure and Informative API Keys : r/programming

6 of 7

https://www.reddit.com/r/programming/comments/1g6qkai/...

encoded, I wouldn't have been able to deduce that just by looking at it.
r/programming

EDIT: Guess I just don’t work with Base64 encoded values enough!

Create

[deleted] • 1y ago

Comment deleted by user

tommcdo • 1y ago

I'm guessing eyJ is just the base64 encoding of { . It makes a lot of sense, I've noticed this as a
frequent beginning of JWT tokens but never thought about why.

schlenk • 1y ago

Its pretty similar to the YII prefix found for Kerberos Negotiate HTTP Authentication, just an
artifact of the Base64 and ASN.1 encoding.

Acc3ssViolation • 1y ago

Ah, of course, caused by the {" in base64. W3s aka [{" is also an option in case the root is
an array of objects, not sure how common that is

bradfordw • 1y ago

The equals signs are (often) a good indicator, especially if they’re at the end of what might look like a
segment

mouse_8b • 1y ago

Base64 would be my first try for pretty much any garbled text I suspect to be encoded

Mognakor • 1y ago

You can tell by the alphabet if it is a candidate. You have A-Za-z0-9+/ and = at the end for padding.
• So if it ends in = it's a candidate.
• If it has a mixture of lower- and uppercase letters, it's a candidate
• If it has parts that fit the criteria but there is a different character mixed in that might be a
delimiter, e.g. JWTs have 3-5 segments delimited by a dot, and the first 2 are base64 encoded
JSON

2/27/26, 1:18 PM

Designing Secure and Informative API Keys : r/programming

7 of 7

https://www.reddit.com/r/programming/comments/1g6qkai/...

punkpeye OP • 1y ago
r/programming
Create
That's a good question! I have no idea. I just pasted the API key into the article, and maybe because it
is longer than the others, I tried to base64 decode it. Maybe I had a rainman moment without realizing
it

Pheasn • 1y ago

What is stopping a user from altering the base64 payload? There doesn't seem to be a signature
involved, so I hope you're not blindly trusting the encoded information in the backend.
If you want to avoid rolling your own API key structure (and cryptography) - and you usually should avoid
that - you could use JWTs instead. In your case a symmetric signature is probably fine (HSnnn).
Otherwise, I'd recommend an algorithm based on elliptic curve cryptography (ESnnn) to get shorter API
keys with the same security level as the RSA-based algorithms.
Obviously JWTs don't give you the nice company-identifying prefix, but you can encode that in the JWT
payload, same as the standard "kid" (key ID) payload claim.

[deleted] • 1y ago

Comment removed by moderator

iamapizza • 1y ago

Yeah came to post this as well, it's a good way for providers to know that their key was leaked. For
example if you push a gh_ key to Github you could get an email saying that your key was
compromised, because there are many services 'watching' public git pushes.

punkpeye OP • 1y ago

Oh that’s cool trivia

Reddit Rules Privacy Policy User Agreement Your Privacy Choices Accessibility Reddit, Inc. © 2026. All rights reserved.

2/27/26, 1:18 PM

